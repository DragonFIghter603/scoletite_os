     1                                  [bits 16]
     2                                  
     3                                  ; extern _start
     4                                  extern SECOND_STAGE_LENGTH
     5                                  global _boot
     6                                  
     7                                  section .boot.text
     8                                  _boot:
     9 00000000 FA                          cli
    10 00000001 31C0                        xor ax, ax
    11 00000003 8ED8                        mov ds, ax
    12 00000005 8ED0                        mov ss, ax
    13 00000007 B80090                      mov ax, 0x9000
    14 0000000A 89C4                        mov sp, ax
    15 0000000C FB                          sti
    16                                  
    17 0000000D E81700                  	call load_second_stage
    18 00000010 EB5D                    	jmp enter_protected
    19                                  
    20                                  
    21                                  [bits 32]
    22                                  boot_pm:
    23 00000012 E8BD000000                  call check_cpuid
    24 00000017 E9F4000000                  jmp enter_long
    25                                  
    26                                  
    27                                  [bits 64]
    28                                  
    29                                  boot_lm:
    30                                      ;jmp _start
    31 0000001C BE[00020000]                mov esi, msg_booted
    32 00000021 E879000000                  call protected_print
    33 00000026 F4                          hlt
    34                                  
    35                                  %include "load_second_stage.asm"
    36                              <1> [bits 16]
    37                              <1> ; buffer at 0x7E00
    38                              <1> load_second_stage:
    39 00000027 60                  <1> 	pusha
    40 00000028 FA                  <1>     cli
    41 00000029 B8E007              <1>     mov ax, 0x7e0
    42 0000002C 8EC0                <1>     mov es, ax
    43 0000002E FB                  <1>     sti
    44                              <1> 
    45 0000002F BB0000              <1>     mov bx, 0x0
    46 00000032 B402                <1>     mov ah, 0x2 ; int 0x13, ah = 0x2
    47 00000034 B0[00]              <1>     mov al, SECOND_STAGE_LENGTH ; n of sectors to read
    48 00000036 50                  <1>     push ax
    49 00000037 B500                <1>     mov ch, 0x0 ; cylinder
    50 00000039 B600                <1>     mov dh, 0x0 ; head
    51 0000003B B102                <1>     mov cl, 0x2 ; sector right after bootloader
    52                              <1>     ; buffer address es:bx
    53 0000003D BB0000              <1>     mov bx, 0x0
    54 00000040 CD13                <1>     int 0x13
    55                              <1> 
    56 00000042 5B                  <1>     pop bx
    57                              <1> 
    58 00000043 38D8                <1>     cmp al, bl
    59 00000045 7502                <1>     jne load_second_error
    60                              <1>         
    61 00000047 61                  <1>     popa
    62 00000048 C3                  <1>     ret
    63                              <1> 
    64                              <1>     load_second_error:
    65 00000049 B40E                <1>         mov ah, 0xe
    66 0000004B B065                <1>         mov al, "e"
    67 0000004D CD10                <1>         int 0x10
    68 0000004F EBFE                <1>         jmp $
    36                                  %include "gdt.asm"
    37                              <1> [bits 16]
    38                              <1> gdt:
    39                              <1> 
    40                              <1> gdt_null:
    41 00000051 0000000000000000    <1>     dq 0x0
    42                              <1> 
    43                              <1> gdt_code:
    44 00000059 FFFF                <1>     dw 0xFFFF ; length
    45 0000005B 0000                <1>     dw 0x0 ; base 0-15
    46 0000005D 00                  <1>     db 0x0 ; base 16-23
    47                              <1>     ; 7 - present flag
    48                              <1>     ; 5-6 - required privelige
    49                              <1>     ; 4 - is either code or data?
    50                              <1>     ; 3 - code or data?
    51                              <1>     ; 2 - is lower privelige allowed to read/exec?
    52                              <1>     ; 1 - read or write?
    53                              <1>     ; 0 - access flag
    54 0000005E 9A                  <1>     db 0b1001_1010
    55                              <1> 
    56                              <1>     ; 7 - granularity (multiplies segment limit by 4kB)
    57                              <1>     ; 6 - 16 bit or 32 bit?
    58                              <1>     ; 5 - required by intel to be set to 0
    59                              <1>     ; 4 - free to use
    60                              <1>     ; 0-3 - last bits of segment limit
    61 0000005F CF                  <1>     db 0b1100_1111
    62                              <1> 
    63 00000060 00                  <1>     db 0x0 ; base 24-31
    64                              <1>     
    65                              <1> gdt_data:
    66 00000061 FFFF                <1>     dw 0xFFFF ; size
    67 00000063 0000                <1>     dw 0x0 ; base 0-15
    68 00000065 00                  <1>     db 0x0 ; base 16-23
    69                              <1>     ; 7 - present flag
    70                              <1>     ; 5-6 - required privelige
    71                              <1>     ; 4 - is either code or data?
    72                              <1>     ; 3 - code or data?
    73                              <1>     ; 2 - is lower privelige allowed to read/exec?
    74                              <1>     ; 1 - read or write?
    75                              <1>     ; 0 - access flag
    76 00000066 92                  <1>     db 0b1001_0010
    77                              <1> 
    78                              <1>     ; 7 - granularity (multiplies segment limit by 4kB)
    79                              <1>     ; 6 - 16 bit or 32 bit?
    80                              <1>     ; 5 - required by intel to be set to 0
    81                              <1>     ; 4 - free to use
    82                              <1>     ; 0-3 - last bits of segment limit
    83 00000067 CF                  <1>     db 0b1100_1111
    84                              <1> 
    85 00000068 00                  <1>     db 0x0 ; base 24-31
    86                              <1> gdt_end:
    87                              <1> 
    88                              <1> gdt_desc:
    89 00000069 1700                <1>     dw gdt_end - gdt - 1
    90 0000006B [51000000]          <1>     dd gdt
    91                              <1> 
    92                              <1> CODE_SEG equ gdt_code - gdt
    93                              <1> DATA_SEG equ gdt_data - gdt
    37                                  %include "enter_protected.asm"
    38                              <1> [bits 16]
    39                              <1> enter_protected:
    40 0000006F FA                  <1>     cli 					; Switch off interrupts until we set up the protected mode interrupt vector
    41 00000070 0F0116[6900]        <1>     lgdt [gdt_desc] 	; Load the global descriptor table which defines the protected mode segments
    42                              <1> 
    43 00000075 0F20C0              <1>     mov eax, cr0 	; Get the value currently in cr0
    44 00000078 6683C801            <1>     or eax, 0x1 	; Set the first bit
    45 0000007C 0F22C0              <1>     mov cr0, eax	; Make the actual switch to protected mode
    46                              <1> 
    47 0000007F EA[8400]0800        <1>     jmp CODE_SEG:init_protected
    48                              <1> 
    49                              <1> [bits 32]
    50                              <1> init_protected:
    51 00000084 F4                  <1>     hlt
    52                              <1>     ; make sure segment register have right values
    53 00000085 66B81000            <1>     mov ax, DATA_SEG
    54 00000089 8ED8                <1>     mov ds, ax
    55 0000008B 8ED0                <1>     mov ss, ax
    56 0000008D 8EC0                <1>     mov es, ax
    57 0000008F 8EE0                <1>     mov fs, ax
    58 00000091 8EE8                <1>     mov gs, ax
    59                              <1> 
    60                              <1>     ; update the stack right at the top of the free space
    61 00000093 BD00000900          <1>     mov ebp, 0x90000
    62 00000098 89EC                <1>     mov esp, ebp
    63                              <1> 
    64 0000009A E973FFFFFF          <1>     jmp boot_pm
    38                                  %include "protected_print.asm"
    39                              <1> [bits 32]
    40                              <1> ; assumes string beggining in %esi
    41                              <1> protected_print:
    42 0000009F 60                  <1>     pusha
    43 000000A0 BA00800B00          <1>     mov edx, 0xb8000
    44 000000A5 B40F                <1>     mov ah, 0x0f
    45                              <1> 
    46                              <1>     protected_print_loop:
    47 000000A7 8A06                <1>         mov al, [esi]
    48 000000A9 3C00                <1>         cmp al, 0
    49 000000AB 740B                <1>         je protected_print_ret
    50                              <1> 
    51 000000AD 668902              <1>         mov [edx], ax
    52 000000B0 83C202              <1>         add edx, 2
    53 000000B3 83C601              <1>         add esi, 1
    54                              <1>         
    55 000000B6 EBEF                <1>         jmp protected_print_loop
    56                              <1> 
    57                              <1>     protected_print_ret:
    58 000000B8 61                  <1>         popa
    59 000000B9 C3                  <1>         ret
    60                              <1>     
    39                                  %include "debug.asm"
    40                              <1> [bits 32]
    41                              <1> 
    42                              <1> ; prints debug code stored in al
    43                              <1> debug:
    44 000000BA A200800B00          <1>     mov byte [0xb8000], al
    45 000000BF C60501800B0020      <1>     mov byte [0xb8001], 0x20
    46 000000C6 882502800B00        <1>     mov byte [0xb8002], ah
    47 000000CC C60503800B0020      <1>     mov byte [0xb8003], 0x20
    48 000000D3 C3                  <1>     ret
    40                                  %include "cpuid.asm"
    41                              <1> [bits 32]
    42                              <1> 
    43                              <1> check_cpuid:
    44 000000D4 60                  <1>     pusha
    45                              <1> 
    46                              <1> 	; get flags and check if cpuid available
    47 000000D5 9C                  <1> 	pushfd
    48 000000D6 58                  <1> 	pop eax
    49                              <1> 	
    50 000000D7 89C1                <1> 	mov ecx, eax
    51                              <1> 
    52 000000D9 3500002000          <1> 	xor eax, 1 << 21
    53                              <1> 
    54 000000DE 50                  <1> 	push eax
    55 000000DF 9D                  <1> 	popfd
    56                              <1> 
    57 000000E0 9C                  <1> 	pushfd
    58 000000E1 58                  <1> 	pop eax
    59                              <1> 
    60 000000E2 31C8                <1> 	xor eax, ecx
    61 000000E4 741F                <1> 	jz no_lm
    62                              <1> 	
    63                              <1>     ; check for long mode instructions
    64 000000E6 B800000080          <1>     mov eax, 0x8000_0000
    65 000000EB 0FA2                <1>     cpuid
    66 000000ED 3D01000080          <1>     cmp eax, 0x8000_0001
    67 000000F2 7211                <1>     jb no_lm
    68                              <1> 
    69                              <1>     ; check if long mode present
    70 000000F4 B801000080          <1>     mov eax, 0x8000_0001
    71 000000F9 0FA2                <1>     cpuid
    72 000000FB F7C200000020        <1>     test edx, 1 << 29
    73 00000101 7402                <1>     jz no_lm
    74                              <1> 
    75 00000103 61                  <1> 	popa
    76                              <1> 
    77 00000104 C3                  <1> 	ret
    78                              <1> 	
    79                              <1> 	no_lm:
    80 00000105 66B82031            <1>     	mov ax, " 1"
    81 00000109 E8ACFFFFFF          <1>     	call debug
    82 0000010E EBFE                <1>     	jmp $
    41                                  %include "enter_long.asm"
    42                              <1> [bits 32]
    43                              <1> ; enter long mode
    44                              <1> ; https://wiki.osdev.org/Setting_Up_Long_Mode#The_Switch_from_Protected_Mode
    45                              <1> 
    46                              <1> ; todo read:
    47                              <1> ; https://stackoverflow.com/questions/25210084/entering-long-mode
    48                              <1> ; https://wiki.osdev.org/Paging#Enabling
    49                              <1> ; https://intermezzos.github.io/book/first-edition/paging.html
    50                              <1> 
    51                              <1> enter_long:
    52                              <1> 	; clear 4 * 4096 bytes of memory starting at 0x1000
    53 00000110 BF00100000          <1>     mov edi, 0x1000
    54 00000115 0F22DF              <1>     mov cr3, edi ; physical address of the page table
    55                              <1> 
    56 00000118 31C0                <1>     xor eax, eax
    57 0000011A B900100000          <1>     mov ecx, 4096
    58 0000011F F3AB                <1>     rep stosd ; move eax to (edi + 4 bytes * counter) ecx times
    59                              <1>     ; edi is pointing to the last byte cleared so must reset
    60 00000121 BF00100000          <1>     mov edi, 0x1000
    61                              <1> 
    62                              <1> 	; 0x2000 = 2 * 16^3 = 2 * 2^12 = 2 << 12
    63                              <1> 	; pages are aligned to 4096 bytes, so to get the
    64                              <1> 	; page address we just need to zero the last 12 bits
    65                              <1> 	; of the entry
    66 00000126 C70703200000        <1>     mov dword [edi], 0x2003 ; 2 << 12 | 0b11 <- flags
    67 0000012C 81C700100000        <1>     add edi, 0x1000 ; 4096
    68 00000132 C70703300000        <1>     mov dword [edi], 0x3003
    69 00000138 81C700100000        <1>     add edi, 0x1000
    70 0000013E C70703400000        <1>     mov dword [edi], 0x4003
    71 00000144 81C700100000        <1>     add edi, 0x1000 ; edi = 0x4000
    72                              <1> 
    73 0000014A BB03000000          <1>     mov ebx, 0b11 ; flags
    74 0000014F B900020000          <1>     mov ecx, 512
    75                              <1>     ; identity map first MB
    76                              <1>     .set_entry:
    77 00000154 891F                <1>     mov dword [edi], ebx
    78 00000156 81C300100000        <1>     add ebx, 0x1000
    79 0000015C 83C708              <1>     add edi, 8
    80 0000015F E2F3                <1> 	loop .set_entry
    81                              <1> 
    82                              <1> 	; enable physical address extension (4 Mb pages)
    83 00000161 0F20E0              <1> 	mov eax, cr4
    84 00000164 83C820              <1> 	or eax, 1 << 5
    85 00000167 0F22E0              <1> 	mov cr4, eax
    86                              <1> 
    87                              <1> 	; set long mode bit
    88 0000016A B9800000C0          <1> 	mov ecx, 0xc000_0080
    89 0000016F 0F32                <1> 	rdmsr
    90 00000171 0D00010000          <1> 	or eax, 1 << 8
    91 00000176 0F30                <1> 	wrmsr
    92                              <1> 	
    93                              <1> 	; set paging
    94 00000178 0F20C0              <1> 	mov eax, cr0
    95 0000017B 0D01000080          <1> 	or eax, 0x80000001
    96 00000180 0F22C0              <1>     mov cr0, eax
    97                              <1> 
    98 00000183 0F0115[A9010000]    <1> 	lgdt [long_gdt.pointer]
    99                              <1> 
   100 0000018A EA[B3010000]0800    <1> 	jmp long_gdt.code_desc:init_long
   101                              <1> 
   102                              <1> 
   103                              <1> ; https://intermezzos.github.io/book/first-edition/setting-up-a-gdt.html
   104                              <1> long_gdt:
   105                              <1>     .null_desc: equ $ - long_gdt
   106 00000191 0000000000000000    <1>     dq 0
   107                              <1>     
   108                              <1>     .code_desc: equ $ - long_gdt
   109 00000199 00000000009A2000    <1>     dq (1 << 53) | (1 << 47) | (1 << 44) | (1 << 43) | (1 << 41)
   110                              <1>     ; 53 - long mode
   111                              <1>     ; 47 - present
   112                              <1>     ; 44 - either code or data
   113                              <1>     ; 43 - executable
   114                              <1>     ; 41 - is data writable/is code readable
   115                              <1>     
   116                              <1>     .data_desc: equ $ - long_gdt
   117 000001A1 0000000000920000    <1>     dq (1 << 47) | (1 << 44) | (1 << 41)
   118                              <1>     
   119                              <1>     .pointer:
   120 000001A9 1700                <1>     dw $ - long_gdt - 1
   121 000001AB [9101000000000000]  <1>     dq long_gdt
   122                              <1> 
   123                              <1> [bits 64]
   124                              <1> init_long:
   125 000001B3 FA                  <1>     cli                           ; Clear the interrupt flag.
   126 000001B4 66B81000            <1>     mov ax, long_gdt.data_desc            ; Set the A-register to the data descriptor.
   127 000001B8 8ED8                <1>     mov ds, ax                    ; Set the data segment to the A-register.
   128 000001BA 8EC0                <1>     mov es, ax                    ; Set the extra segment to the A-register.
   129 000001BC 8EE0                <1>     mov fs, ax                    ; Set the F-segment to the A-register.
   130 000001BE 8EE8                <1>     mov gs, ax                    ; Set the G-segment to the A-register.
   131 000001C0 8ED0                <1>     mov ss, ax                    ; Set the stack segment to the A-register.
   132 000001C2 E955FEFFFF          <1>     jmp boot_lm
    42                                  
    43 000001C7 00<rep 37h>             times 510 - ($-$$) db 0
    44 000001FE 55AA                    dw 0xaa55  ; 0x55AA, its little endian
    45                                  
    46 00000200 626F6F74656400          msg_booted: db "booted", 0
