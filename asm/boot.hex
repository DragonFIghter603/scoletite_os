     1                                  [bits 16]
     2                                  
     3                                  extern _start
     4                                  extern SECOND_STAGE_LENGTH
     5                                  global _boot
     6                                  
     7                                  _boot:
     8 00000000 8816[EC01]                  mov [BOOT_DRIVE], dl    ; store boot drive for later
     9                                  
    10 00000004 BD0090                      mov bp, 0x9000			; setup the stack
    11 00000007 89EC                        mov sp, bp
    12                                  
    13                                      ; print messages
    14 00000009 BB[ED01]                    mov bx, MSG_REAL_MODE
    15 0000000C E82400                      call print_string
    16                                  
    17 0000000F FA                          cli
    18 00000010 31C0                        xor ax, ax
    19 00000012 8ED8                        mov ds, ax
    20 00000014 8ED0                        mov ss, ax
    21 00000016 B80090                      mov ax, 0x9000
    22 00000019 89C4                        mov sp, ax
    23 0000001B FB                          sti
    24                                  
    25 0000001C E8EC00                  	call load_second_stage
    26 0000001F E9B100                  	jmp enter_protected
    27                                  
    28                                  
    29                                  [bits 32]
    30                                  boot_pm:
    31 00000022 E856000000                  call check_cpuid
    32 00000027 E909010000                  jmp enter_long
    33                                  
    34                                  
    35                                  [bits 64]
    36                                  
    37                                  boot_lm:
    38 0000002C E9(00000000)                jmp _start
    39                                  loop_end:
    40 00000031 EBFE                        jmp loop_end
    41                                  
    42                                  %include "print.asm"
    43                              <1> [bits 16]
    44                              <1> ; bx is the register that holds the address of the string
    45                              <1> print_string:
    46 00000033 60                  <1>     pusha
    47 00000034 B40E                <1>     mov ah, 0x0e ; int 0x10 with ah = 0x0e -> means scrolling teletype
    48                              <1> 
    49                              <1> loop:
    50 00000036 803F00              <1>     cmp [bx], byte 0
    51 00000039 7407                <1>     je endloop
    52                              <1> 
    53 0000003B 8A07                <1>     mov al, [bx]
    54 0000003D CD10                <1>     int 0x10
    55 0000003F 43                  <1>     inc bx
    56 00000040 EBF4                <1>     jmp loop
    57                              <1> 
    58                              <1> endloop:
    59 00000042 61                  <1>     popa
    60 00000043 C3                  <1>     ret
    61                              <1> 
    62                              <1> [bits 32]
    63                              <1> ; print a null terminated string pointed by EBX
    64                              <1> VIDEO_MEMORY equ 0xb8000 ; #define VIDEO_MEMORY 0xb8000. To display a character in text mode, we need to set
    65                              <1>                          ; 2 bytes in the correct index in the Video Graphics Array(80x25).
    66                              <1>                          ; First byte is the ascii code  and the second encodes the character attributes.
    67                              <1>                          ; To find the index 0xb8000 + 2 * (row * 80 + col)
    68                              <1> WHITE_ON_BLACK equ 0x0f
    69                              <1> 
    70                              <1> print_string_pm:
    71 00000044 60                  <1>     pusha
    72 00000045 BA00800B00          <1>     mov edx, VIDEO_MEMORY
    73                              <1> print_string_pm_loop:
    74 0000004A 8A03                <1>     mov al, [ebx] ; Store the char at ebx in AL
    75 0000004C B40F                <1>     mov ah, WHITE_ON_BLACK ; Store the attributes in AH
    76                              <1> 
    77 0000004E 3C00                <1>     cmp al, 0 ; Check if we hit the null terminator
    78 00000050 740B                <1>     je print_string_pm_done
    79                              <1> 
    80 00000052 668902              <1>     mov [edx], ax ; Store the char and the attributes at the correct index in the VGA
    81                              <1> 
    82 00000055 83C301              <1>     add ebx, 1 ; Next char in string
    83 00000058 83C202              <1>     add edx, 2 ; Next cell in VGA
    84                              <1> 
    85 0000005B EBED                <1>     jmp print_string_pm_loop
    86                              <1> 
    87                              <1> print_string_pm_done:
    88 0000005D 61                  <1>     popa
    89 0000005E C3                  <1>     ret
    43                                  %include "gdt.asm"
    44                              <1> [bits 16]
    45                              <1> ; GDT - Global Descriptor Table
    46                              <1> ; We define a basic flat model in which the sectors overlap and cover all 4GB of addressable memory
    47                              <1> gdt_start:
    48                              <1> 
    49                              <1> gdt_null: ; The mandatory null descriptor
    50 0000005F 00000000            <1> 	dd 0x0
    51 00000063 00000000            <1> 	dd 0x0
    52                              <1> 
    53                              <1> gdt_code: ; The code segment descriptor
    54                              <1> 	; Base = 0x0, Limit = 0xfffff
    55                              <1> 	; 1st flag = (present)1 (privilege)00 (descriptor type)1 -> 1001b
    56                              <1> 	; type flag = (code)1 (conforming)0 (readable)1 (accessed)0 -> 1010b
    57                              <1> 	; 2rd flag = (granularity)1 (32bit)1 (64bit)0 (avl)0 -> 1100b
    58 00000067 FFFF                <1> 	dw 0xffff		; Limit (bits 0-15)
    59 00000069 0000                <1> 	dw 0x0			; Base (bits 0-15)
    60 0000006B 00                  <1> 	db 0x0			; Base (bits 16-23)
    61 0000006C 9A                  <1> 	db 10011010b 	; 1st flag, type flags
    62 0000006D CF                  <1> 	db 11001111b	; Second flag, Limit (bits 16-19)
    63 0000006E 00                  <1> 	db 0x0			; Base (bits 24-31)
    64                              <1> 
    65                              <1> gdt_data: ; The data segment descriptor
    66                              <1> 	; Same as the code segment except for the type flags
    67                              <1> 	; type flags = (code)0 (expand down)0 (writeable)1 (accessed)0 -> 0010b
    68 0000006F FFFF                <1> 	dw 0xffff		; Limit (bits 0-15)
    69 00000071 0000                <1> 	dw 0x0			; Base (bits 0-15)
    70 00000073 00                  <1> 	db 0x0			; Base(bits 16-23)
    71 00000074 92                  <1> 	db 10010010b	; 1st flag, type flags(for data)
    72 00000075 CF                  <1> 	db 11001111b	; Second flag, Limit(bits 16-19)
    73 00000076 00                  <1> 	db 0x0			; Base (bits 24-31)
    74                              <1> 
    75                              <1> gdt_end: ; This is to let the assembler calculate the size of the gdt for the gdt descriptor
    76                              <1> 
    77                              <1> gdt_desc:
    78 00000077 1700                <1> 	dw gdt_end - gdt_start - 1		; Size of our GDT, one less than the true size
    79 00000079 [5F000000]          <1> 	dd gdt_start 					; Start address of our GDT
    80                              <1> 
    81                              <1> 
    82                              <1> ; Useful constants to put in the segment registers so that the CPU knows what segment we want to use
    83                              <1> ; 0x0 for null segment
    84                              <1> ; 0x8 for code segment
    85                              <1> ; 0x10 for data segment
    86                              <1> CODE_SEG equ gdt_code - gdt_start
    87                              <1> DATA_SEG equ gdt_data - gdt_start
    44                                  %include "cpuid.asm"
    45                              <1> [bits 32]
    46                              <1> 
    47                              <1> check_cpuid:
    48 0000007D 60                  <1>     pusha
    49                              <1> 
    50                              <1> 	; get flags and check if cpuid available
    51 0000007E 9C                  <1> 	pushfd
    52 0000007F 58                  <1> 	pop eax
    53                              <1> 	
    54 00000080 89C1                <1> 	mov ecx, eax
    55                              <1> 
    56 00000082 3500002000          <1> 	xor eax, 1 << 21
    57                              <1> 
    58 00000087 50                  <1> 	push eax
    59 00000088 9D                  <1> 	popfd
    60                              <1> 
    61 00000089 9C                  <1> 	pushfd
    62 0000008A 58                  <1> 	pop eax
    63                              <1> 
    64 0000008B 31C8                <1> 	xor eax, ecx
    65 0000008D 741F                <1> 	jz no_lm
    66                              <1> 	
    67                              <1>     ; check for long mode instructions
    68 0000008F B800000080          <1>     mov eax, 0x8000_0000
    69 00000094 0FA2                <1>     cpuid
    70 00000096 3D01000080          <1>     cmp eax, 0x8000_0001
    71 0000009B 7211                <1>     jb no_lm
    72                              <1> 
    73                              <1>     ; check if long mode present
    74 0000009D B801000080          <1>     mov eax, 0x8000_0001
    75 000000A2 0FA2                <1>     cpuid
    76 000000A4 F7C200000020        <1>     test edx, 1 << 29
    77 000000AA 7402                <1>     jz no_lm
    78                              <1> 
    79 000000AC 61                  <1> 	popa
    80                              <1> 
    81 000000AD C3                  <1> 	ret
    82                              <1> 	
    83                              <1> 	no_lm:
    84 000000AE 66B82031            <1>     	mov ax, " 1"
    85 000000B2 E802000000          <1>     	call debug
    86 000000B7 EBFE                <1>     	jmp $
    45                                  %include "debug.asm"
    46                              <1> [bits 32]
    47                              <1> 
    48                              <1> ; prints debug code stored in al
    49                              <1> debug:
    50 000000B9 A200800B00          <1>     mov byte [0xb8000], al
    51 000000BE C60501800B0020      <1>     mov byte [0xb8001], 0x20
    52 000000C5 882502800B00        <1>     mov byte [0xb8002], ah
    53 000000CB C60503800B0020      <1>     mov byte [0xb8003], 0x20
    54 000000D2 C3                  <1>     ret
    46                                  %include "enter_protected.asm"
    47                              <1> [bits 16]
    48                              <1> enter_protected:
    49 000000D3 FA                  <1>     cli 					; Switch off interrupts until we set up the protected mode interrupt vector
    50 000000D4 0F0116[7700]        <1>     lgdt [gdt_desc] 	    ; Load the global descriptor table which defines the protected mode segments
    51                              <1> 
    52 000000D9 0F20C0              <1>     mov eax, cr0 	; Get the value currently in cr0
    53 000000DC 6683C801            <1>     or eax, 0x1 	; Set the first bit
    54 000000E0 0F22C0              <1>     mov cr0, eax	; Make the actual switch to protected mode
    55 000000E3 EA[E800]0800        <1>     jmp CODE_SEG:init_protected ; Make a far jump to our 32 bit code. This forces the CPU to flush its cache of prefetched
    56                              <1>     							; and real mode decoded instructions. This also sets cs to be the CODE_SEG which is what
    57                              <1>     							; we will do for all the data segment registers(far jmp is cs:ip so this is like mov cs, CODE_SEG)
    58                              <1> 
    59                              <1> [bits 32]
    60                              <1> init_protected:
    61                              <1>         lllll:
    62 000000E8 EBFE                <1>                 jmp lllll
    63 000000EA 66B81000            <1>     mov ax, DATA_SEG 	; Now that we are in pm, old segments are meaningless and we must
    64                              <1>     					; point our segment registers to the data segment we defined in the GDT
    65 000000EE 8ED8                <1>     mov ds, ax
    66                              <1> 
    67 000000F0 8ED0                <1>     mov ss, ax
    68 000000F2 8EC0                <1>     mov es, ax
    69 000000F4 8EE0                <1>     mov fs, ax
    70 000000F6 8EE8                <1>     mov gs, ax
    71                              <1> 
    72                              <1>     ; update the stack right at the top of the free space
    73 000000F8 BD00000900          <1>     mov ebp, 0x90000
    74                              <1> 
    75                              <1>     ; print message
    76 000000FD 66BB[F001]          <1>     mov bx, MSG_PM
    77 00000101 E83EFFFFFF          <1>     call print_string_pm
    78 00000106 E917FFFFFF          <1>     jmp boot_pm
    47                                  %include "load_second_stage.asm"
    48                              <1> [bits 16]
    49                              <1> ; buffer at 0x7E00
    50                              <1> load_second_stage:
    51 0000010B 60                  <1> 	pusha
    52 0000010C FA                  <1>     cli
    53 0000010D B8E007              <1>     mov ax, 0x7e0
    54 00000110 8EC0                <1>     mov es, ax
    55 00000112 FB                  <1>     sti
    56                              <1> 
    57 00000113 BB0000              <1>     mov bx, 0x0
    58 00000116 B402                <1>     mov ah, 0x2 ; int 0x13, ah = 0x2
    59 00000118 B0[00]              <1>     mov al, SECOND_STAGE_LENGTH ; n of sectors to read
    60 0000011A 50                  <1>     push ax
    61 0000011B B500                <1>     mov ch, 0x0 ; cylinder
    62 0000011D B600                <1>     mov dh, 0x0 ; head
    63 0000011F B102                <1>     mov cl, 0x2 ; sector right after bootloader
    64                              <1>     ; buffer address es:bx
    65 00000121 BB0000              <1>     mov bx, 0x0
    66 00000124 CD13                <1>     int 0x13
    67                              <1> 
    68 00000126 5B                  <1>     pop bx
    69                              <1> 
    70 00000127 38D8                <1>     cmp al, bl
    71 00000129 7502                <1>     jne load_second_error
    72                              <1>         
    73 0000012B 61                  <1>     popa
    74 0000012C C3                  <1>     ret
    75                              <1> 
    76                              <1>     load_second_error:
    77 0000012D B40E                <1>         mov ah, 0xe
    78 0000012F B065                <1>         mov al, "e"
    79 00000131 CD10                <1>         int 0x10
    80 00000133 EBFE                <1>         jmp $
    48                                  %include "enter_long.asm"
    49                              <1> [bits 32]
    50                              <1> ; enter long mode
    51                              <1> ; https://wiki.osdev.org/Setting_Up_Long_Mode#The_Switch_from_Protected_Mode
    52                              <1> 
    53                              <1> ; todo read:
    54                              <1> ; https://stackoverflow.com/questions/25210084/entering-long-mode
    55                              <1> ; https://wiki.osdev.org/Paging#Enabling
    56                              <1> ; https://intermezzos.github.io/book/first-edition/paging.html
    57                              <1> 
    58                              <1> enter_long:
    59                              <1> 	; clear 4 * 4096 bytes of memory starting at 0x1000
    60 00000135 BF00100000          <1>     mov edi, 0x1000
    61 0000013A 0F22DF              <1>     mov cr3, edi ; physical address of the page table
    62                              <1> 
    63 0000013D 31C0                <1>     xor eax, eax
    64 0000013F B900100000          <1>     mov ecx, 4096
    65 00000144 F3AB                <1>     rep stosd ; move eax to (edi + 4 bytes * counter) ecx times
    66                              <1>     ; edi is pointing to the last byte cleared so must reset
    67 00000146 BF00100000          <1>     mov edi, 0x1000
    68                              <1> 
    69                              <1> 	; 0x2000 = 2 * 16^3 = 2 * 2^12 = 2 << 12
    70                              <1> 	; pages are aligned to 4096 bytes, so to get the
    71                              <1> 	; page address we just need to zero the last 12 bits
    72                              <1> 	; of the entry
    73 0000014B C70703200000        <1>     mov dword [edi], 0x2003 ; 2 << 12 | 0b11 <- flags
    74 00000151 81C700100000        <1>     add edi, 0x1000 ; 4096
    75 00000157 C70703300000        <1>     mov dword [edi], 0x3003
    76 0000015D 81C700100000        <1>     add edi, 0x1000
    77 00000163 C70703400000        <1>     mov dword [edi], 0x4003
    78 00000169 81C700100000        <1>     add edi, 0x1000 ; edi = 0x4000
    79                              <1> 
    80 0000016F BB03000000          <1>     mov ebx, 0b11 ; flags
    81 00000174 B900020000          <1>     mov ecx, 512
    82                              <1>     ; identity map first MB
    83                              <1>     .set_entry:
    84 00000179 891F                <1>     mov dword [edi], ebx
    85 0000017B 81C300100000        <1>     add ebx, 0x1000
    86 00000181 83C708              <1>     add edi, 8
    87 00000184 E2F3                <1> 	loop .set_entry
    88                              <1> 
    89                              <1> 	; enable physical address extension (4 Mb pages)
    90 00000186 0F20E0              <1> 	mov eax, cr4
    91 00000189 83C820              <1> 	or eax, 1 << 5
    92 0000018C 0F22E0              <1> 	mov cr4, eax
    93                              <1> 
    94                              <1> 	; set long mode bit
    95 0000018F B9800000C0          <1> 	mov ecx, 0xc000_0080
    96 00000194 0F32                <1> 	rdmsr
    97 00000196 0D00010000          <1> 	or eax, 1 << 8
    98 0000019B 0F30                <1> 	wrmsr
    99                              <1> 	
   100                              <1> 	; set paging
   101 0000019D 0F20C0              <1> 	mov eax, cr0
   102 000001A0 0D01000080          <1> 	or eax, 0x80000001
   103 000001A5 0F22C0              <1>     mov cr0, eax
   104                              <1> 
   105 000001A8 0F0115[CE010000]    <1> 	lgdt [long_gdt.pointer]
   106 000001AF EA[D8010000]0800    <1> 	jmp long_gdt.code_desc:init_long
   107                              <1> 
   108                              <1> 
   109                              <1> ; https://intermezzos.github.io/book/first-edition/setting-up-a-gdt.html
   110                              <1> long_gdt:
   111                              <1>     .null_desc: equ $ - long_gdt
   112 000001B6 0000000000000000    <1>     dq 0
   113                              <1>     
   114                              <1>     .code_desc: equ $ - long_gdt
   115 000001BE 00000000009A2000    <1>     dq (1 << 53) | (1 << 47) | (1 << 44) | (1 << 43) | (1 << 41)
   116                              <1>     ; 53 - long mode
   117                              <1>     ; 47 - present
   118                              <1>     ; 44 - either code or data
   119                              <1>     ; 43 - executable
   120                              <1>     ; 41 - is data writable/is code readable
   121                              <1>     
   122                              <1>     .data_desc: equ $ - long_gdt
   123 000001C6 0000000000920000    <1>     dq (1 << 47) | (1 << 44) | (1 << 41)
   124                              <1>     
   125                              <1>     .pointer:
   126 000001CE 1700                <1>     dw $ - long_gdt - 1
   127 000001D0 [B601000000000000]  <1>     dq long_gdt
   128                              <1> 
   129                              <1> [bits 64]
   130                              <1> init_long:
   131 000001D8 FA                  <1>     cli                           ; Clear the interrupt flag.
   132 000001D9 66B81000            <1>     mov ax, long_gdt.data_desc            ; Set the A-register to the data descriptor.
   133 000001DD 8ED8                <1>     mov ds, ax                    ; Set the data segment to the A-register.
   134 000001DF 8EC0                <1>     mov es, ax                    ; Set the extra segment to the A-register.
   135 000001E1 8EE0                <1>     mov fs, ax                    ; Set the F-segment to the A-register.
   136 000001E3 8EE8                <1>     mov gs, ax                    ; Set the G-segment to the A-register.
   137 000001E5 8ED0                <1>     mov ss, ax                    ; Set the stack segment to the A-register.
   138 000001E7 E940FEFFFF          <1>     jmp boot_lm
    49                                  
    50 000001EC 00                      BOOT_DRIVE db 0 ; gets set at very beginning
    51 000001ED 313600                  MSG_REAL_MODE db "16", 0
    52 000001F0 333200                  MSG_PM db "32", 0
    53 000001F3 363400                  MSG_64 db "64", 0
    54                                  
    55 000001F6 00<rep 8h>              times 510 - ($-$$) db 0
    56 000001FE 55AA                    dw 0xaa55  ; 0x55AA, its little endian
